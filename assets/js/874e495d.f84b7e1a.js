"use strict";(self.webpackChunkjitterphysics=self.webpackChunkjitterphysics||[]).push([[239],{4876:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var i=n(4848),s=n(8453);const a={},o="Contact Generation",l={id:"documentation/04contact-generation",title:"Contact Generation",description:"Jitter exclusively uses algorithms based on the Minkowski sum to detect collisions (available in the NarrowPhase class), i.e., there is no explicit code for the collision of two boxes, for example.",source:"@site/docs/02_documentation/04contact-generation.md",sourceDirName:"02_documentation",slug:"/documentation/04contact-generation",permalink:"/docs/documentation/04contact-generation",draft:!1,unlisted:!1,editUrl:"https://github.com/notgiven688/jitterphysics2/tree/main/docs/docs/02_documentation/04contact-generation.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Ray Casting",permalink:"/docs/documentation/03raycasting"},next:{title:"Jitter Demo",permalink:"/docs/category/jitter-demo"}},r={},c=[{value:"Auxiliary Contacts",id:"auxiliary-contacts",level:2},{value:"Speculative Contacts",id:"speculative-contacts",level:2},{value:"Collision Filters",id:"collision-filters",level:2},{value:"Example: Broadphase Filter",id:"example-broadphase-filter",level:3},{value:"Narrowphase Filter",id:"narrowphase-filter",level:3}];function d(e){const t={annotation:"annotation",code:"code",h1:"h1",h2:"h2",h3:"h3",img:"img",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"contact-generation",children:"Contact Generation"}),"\n",(0,i.jsxs)(t.p,{children:["Jitter exclusively uses algorithms based on the Minkowski sum to detect collisions (available in the ",(0,i.jsx)(t.code,{children:"NarrowPhase"})," class), i.e., there is no explicit code for the collision of two boxes, for example."]}),"\n",(0,i.jsx)(t.p,{children:"The collision of two boxes can serve as an illustrative example: The intersection of two boxes can be empty, a single point, a segment, a two-dimensional surface, or a three-dimensional volume. Handling all these cases in an algorithm is already complicated. The various kinds of results then must be managed by the solver. For instance, the solver must be able to resolve a collision where the intersection of two boxes is a two-dimensional surface, as is generally the case when one box is resting on another."}),"\n",(0,i.jsx)(t.p,{children:"Jitter, like most other engines, handles all cases using contact points. The collision algorithms utilized by Jitter always report the point of deepest penetration as a contact point. The normal is the relative direction both shapes must move in to resolve the collision. Contact points might be cached, as depicted in the following figure where a smaller box rests on top of a larger static one (shown here for two dimensions):"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"contact",src:n(6298).A+"",width:"1055",height:"276"})}),"\n",(0,i.jsx)(t.p,{children:"In each frame (world.Step), only one collision point is generated for a pair of shapes (depicted as a black 'x'). This collision point is forwarded to the solver, which then attempts to resolve the collision. In the next frame, another point might be reported by the collision system. The previous point remains valid. Now both points are solved simultaneously in the solver - the box stabilizes and eventually rests on top of the larger static box. This stabilization over several frames can lead to significant jitter, which might worsen in the general three-dimensional case and also becomes more noticeable with larger time steps. For each collision pair, Jitter stores up to four contacts, which then more or less accurately describe the true contact surface (contact manifold)."}),"\n",(0,i.jsx)(t.h2,{id:"auxiliary-contacts",children:"Auxiliary Contacts"}),"\n",(0,i.jsxs)(t.p,{children:['Jitter employs a technique termed "auxiliary contacts", where additional contacts are generated for the general case where two flat surfaces are in contact. These additional contacts are calculated within one frame, generating the full contact manifold in "one shot", thereby preventing the jittering problem discussed in the last section. The ',(0,i.jsx)(t.code,{children:"world.EnableAuxiliaryContactPoints"})," property can be used to enable or disable the usage of auxiliary contact point generation."]}),"\n",(0,i.jsx)(t.h2,{id:"speculative-contacts",children:"Speculative Contacts"}),"\n",(0,i.jsxs)(t.p,{children:['Speculative contacts can be utilized to prevent fast and small objects from tunneling through thin objects. An object moving quickly enough might "miss" a collision since the distance traveled between two frames exceeds the thickness of another object. Speculative contacts can be enabled on a per-body basis using ',(0,i.jsx)(t.code,{children:"body.EnableSpeculativeContacts"}),". The ",(0,i.jsx)(t.code,{children:"world.SpeculativeRelaxationFactor"})," and ",(0,i.jsx)(t.code,{children:"world.SpeculativeVelocityThreshold"})," can be adjusted to fine-tune speculative contacts for your use case. However, note that an accurate simulation of fast-moving objects is only possible using smaller time steps. Speculative contacts might entail the cost of inaccurate collision detection and/or response."]}),"\n",(0,i.jsx)(t.h2,{id:"collision-filters",children:"Collision Filters"}),"\n",(0,i.jsx)(t.p,{children:"Detected collisions can be filtered out or manipulated before they are used for contact manifold generation."}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"world.BroadPhaseFilter"})," and ",(0,i.jsx)(t.code,{children:"world.NarrowPhaseFilter"})," properties can be utilized to specify custom implementations for the filter interfaces."]}),"\n",(0,i.jsx)(t.h3,{id:"example-broadphase-filter",children:"Example: Broadphase Filter"}),"\n",(0,i.jsx)(t.p,{children:'In this example, we have two "teams", team blue and team red. We will implement a filter that disregards all collisions between team members (rigid bodies) of different colors:'}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cs",children:"public class TeamFilter : IBroadPhaseFilter\n{\n    public class TeamMember { }\n    \n    public static TeamMember TeamRed = new();\n    public static TeamMember TeamBlue = new();\n    \n    public bool Filter(Shape shapeA, Shape shapeB)\n    {\n        if (shapeA.RigidBody.Tag is not TeamMember || shapeB.RigidBody.Tag is not TeamMember)\n        {\n            // Handle collision normally if at least one body is not a member of any team\n            return true;\n        }\n\n        // There is no collision between team red and team blue.\n        return shapeA.RigidBody.Tag != shapeB.RigidBody.Tag;\n    }\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"TeamFilter"})," class can then be instantiated and assigned to ",(0,i.jsx)(t.code,{children:"world.BroadPhaseFilter"}),". Rigid bodies of different colors do not interact:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cs",children:"world.BroadPhaseFilter = new TeamFilter();\n...\nbodyA.Tag = TeamFilter.TeamBlue;\nbodyB.Tag = TeamFilter.TeamRed;\nbodyC.Tag = TeamFilter.TeamRed;\n"})}),"\n",(0,i.jsx)(t.h3,{id:"narrowphase-filter",children:"Narrowphase Filter"}),"\n",(0,i.jsx)(t.p,{children:"The narrow phase filter operates similarly. However, the callback is called after narrow-phase collision detection, meaning detailed collision information (normal, penetration depth, collision points) is available at this stage."}),"\n",(0,i.jsxs)(t.p,{children:["The default narrow phase collision filter in Jitter is assigned to an instance of ",(0,i.jsx)(t.code,{children:"TriangleEdgeCollisionFilter"}),', which filters out so-called "internal edges". Consider the following example of a box sliding on static triangles (referred to as "ground", depicted here in 2D as blue and red segments):']}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"contact",src:n(1414).A+"",width:"1057",height:"384"})}),"\n",(0,i.jsx)(t.p,{children:"The box slightly sinks into the ground due to the possibility of the collision from gravity not being perfectly resolved by design (the solver permits a small penetration)."}),"\n",(0,i.jsxs)(t.p,{children:["For ",(0,i.jsxs)(t.span,{className:"katex",children:[(0,i.jsx)(t.span,{className:"katex-mathml",children:(0,i.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(t.semantics,{children:[(0,i.jsxs)(t.mrow,{children:[(0,i.jsx)(t.mi,{children:"t"}),(0,i.jsx)(t.mo,{children:"="}),(0,i.jsx)(t.mn,{children:"1"})]}),(0,i.jsx)(t.annotation,{encoding:"application/x-tex",children:"t=1"})]})})}),(0,i.jsxs)(t.span,{className:"katex-html","aria-hidden":"true",children:[(0,i.jsxs)(t.span,{className:"base",children:[(0,i.jsx)(t.span,{className:"strut",style:{height:"0.6151em"}}),(0,i.jsx)(t.span,{className:"mord mathnormal",children:"t"}),(0,i.jsx)(t.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,i.jsx)(t.span,{className:"mrel",children:"="}),(0,i.jsx)(t.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,i.jsxs)(t.span,{className:"base",children:[(0,i.jsx)(t.span,{className:"strut",style:{height:"0.6444em"}}),(0,i.jsx)(t.span,{className:"mord",children:"1"})]})]})]}),', the collision system detects a collision with the red triangle. While this is accurate, the collision normal might point in the opposite direction of the box\'s movement, since this is the direction in which the box and triangle must move to resolve the collision (rather than "lifting" the box up). Consequently, the box stumbles over the internal edge, instead of sliding over the non-existing gap between the two triangles.']})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},6298:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/contact-a002a947dcaddc6f5d811f3edbe1a1ff.png"},1414:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/filter-6059776b3b332de89e8c37cc74d5acc4.png"},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>l});var i=n(6540);const s={},a=i.createContext(s);function o(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);