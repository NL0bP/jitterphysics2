"use strict";(self.webpackChunkjitterphysics=self.webpackChunkjitterphysics||[]).push([[161],{453:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>m,frontMatter:()=>a,metadata:()=>r,toc:()=>d});var i=n(4848),s=n(8453);const a={},o="Unmanaged Memory",r={id:"documentation/00unmanaged-memory",title:"Unmanaged Memory",description:"The constructor of the world class takes three optional arguments, each with quite large default values:",source:"@site/docs/02_documentation/00unmanaged-memory.md",sourceDirName:"02_documentation",slug:"/documentation/00unmanaged-memory",permalink:"/docs/documentation/00unmanaged-memory",draft:!1,unlisted:!1,editUrl:"https://github.com/notgiven688/jitterphysics2/tree/main/docs/docs/02_documentation/00unmanaged-memory.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Documentation",permalink:"/docs/category/documentation"},next:{title:"World Entities",permalink:"/docs/documentation/01world-entities"}},c={},d=[{value:"Accessing Unmanaged Memory",id:"accessing-unmanaged-memory",level:2}];function l(e){const t={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"unmanaged-memory",children:"Unmanaged Memory"}),"\n",(0,i.jsx)(t.p,{children:"The constructor of the world class takes three optional arguments, each with quite large default values:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cs",children:"public World(int numBodies = 32768, int numContacts = 65536, int numConstraints = 32768)\n"})}),"\n",(0,i.jsx)(t.p,{children:"These values specify the maximum number of entities that can exist in the world class. This is unusual for a managed library because the user must commit to a certain maximum size of the simulation, and the parameters cannot be changed after calling the constructor."}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"numBodies"}),": The maximum number of ",(0,i.jsx)(t.strong,{children:"RigidBodies"})," in the simulation. RigidBodies possess attributes such as position, velocity, mass, inertia, and also maintain a list of shapes that exist within the collision system of the engine."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"numContacts"}),': Collisions reported by the collision system are utilized to construct contact manifolds between shapes. A contact manifold contains one to four collision points. The collision points for a pair of shapes are stored in a data structure called "Arbiter". Each pair of shapes can only have one Arbiter. The numContacts parameter refers to the maximum number of ',(0,i.jsx)(t.strong,{children:"Arbiters"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"numConstraints"}),": This parameter indicates the maximum number of ",(0,i.jsx)(t.strong,{children:"Constraints"}),". A constraint limits the positions or velocities of a pair of rigid bodies."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"RigidBodies"}),", ",(0,i.jsx)(t.strong,{children:"Arbiters"}),", and ",(0,i.jsx)(t.strong,{children:"Constraints"})," are regular C# classes that reside on the managed heap. However, these objects are linked to their unmanaged counterparts: ",(0,i.jsx)(t.strong,{children:"RigidBodyData"}),", ",(0,i.jsx)(t.strong,{children:"ContactData"}),", and ",(0,i.jsx)(t.strong,{children:"ConstraintData"}),". Memory management for these structures is facilitated by Jitter: An array of pointers is allocated (referred to as the index-list in the following), where each entry indicates the actual memory of the data structure. These data structures exist in a contiguous blob of allocated memory. The managed classes maintain pointers to the index-list. Whenever the memory position of a native data structure is altered, the index-list gets updated. ",(0,i.jsx)(t.em,{children:"Jitter relocates the native structures in a manner that ensures active objects are housed in contiguous memory, enabling efficient access by the iterative solver"}),". The size of the index-list is dictated by the corresponding number specified in the constructor. For instance, with the default constructor, the index-list can hold 32768 pointers (256 KB on a 64-bit system). The continuous block of memory that hosts the native structures adapts to the actual number of rigid bodies in the simulation in a grow-only manner. Consequently, only 265 KB are initially earmarked for a maximum of 32768 bodies, scaling up to (256 KB + 32768 x {size of RigidBodyData}) of unmanaged memory usage if 32768 bodies are effectively integrated into the simulation."]}),"\n",(0,i.jsx)(t.h2,{id:"accessing-unmanaged-memory",children:"Accessing Unmanaged Memory"}),"\n",(0,i.jsx)(t.admonition,{title:"Raw Memory Access",type:"danger",children:(0,i.jsx)(t.p,{children:"Accessing raw memory is generally not required when utilizing the standard functionalities of Jitter. Although reading the raw data of objects is generally safe, modifying data can corrupt the internal state of the engine."})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"world.RawData"})," facilitates access to ",(0,i.jsx)(t.code,{children:"Span"}),"s into unmanaged contiguous memory. This data is also reachable via ",(0,i.jsx)(t.code,{children:"body.Handle.Data"}),", ",(0,i.jsx)(t.code,{children:"arbiter.Handle.Data"}),", and ",(0,i.jsx)(t.code,{children:"constraint.Handle.Data"}),"."]})]})}function m(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>r});var i=n(6540);const s={},a=i.createContext(s);function o(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);