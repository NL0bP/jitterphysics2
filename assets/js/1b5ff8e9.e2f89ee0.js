"use strict";(self.webpackChunkjitterphysics=self.webpackChunkjitterphysics||[]).push([[183],{6313:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>o,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>c,toc:()=>l});var s=t(4848),n=t(8453);const i={},r="Ray Casting",c={id:"documentation/03raycasting",title:"Ray Casting",description:"Retrieve information about where a ray, defined by an origin and a direction, hits a target. Generally, the actual hit point can be calculated using the fraction value returned by the appropriate functions using the formula:",source:"@site/docs/02_documentation/03raycasting.md",sourceDirName:"02_documentation",slug:"/documentation/03raycasting",permalink:"/docs/documentation/03raycasting",draft:!1,unlisted:!1,editUrl:"https://github.com/notgiven688/jitterphysics2/tree/main/docs/docs/02_documentation/03raycasting.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Simulation Step",permalink:"/docs/documentation/02simulation-step"},next:{title:"Contact Generation",permalink:"/docs/documentation/04contact-generation"}},o={},l=[{value:"Generic Ray Cast for ISupportMap",id:"generic-ray-cast-for-isupportmap",level:2},{value:"Ray Cast Against Shapes",id:"ray-cast-against-shapes",level:2}];function m(e){const a={annotation:"annotation",code:"code",h1:"h1",h2:"h2",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",mspace:"mspace",mtext:"mtext",p:"p",pre:"pre",semantics:"semantics",span:"span",...(0,n.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(a.h1,{id:"ray-casting",children:"Ray Casting"}),"\n",(0,s.jsx)(a.p,{children:"Retrieve information about where a ray, defined by an origin and a direction, hits a target. Generally, the actual hit point can be calculated using the fraction value returned by the appropriate functions using the formula:"}),"\n",(0,s.jsx)(a.span,{className:"katex-display",children:(0,s.jsxs)(a.span,{className:"katex",children:[(0,s.jsx)(a.span,{className:"katex-mathml",children:(0,s.jsx)(a.math,{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block",children:(0,s.jsxs)(a.semantics,{children:[(0,s.jsxs)(a.mrow,{children:[(0,s.jsx)(a.mtext,{mathvariant:"bold",children:"hit"}),(0,s.jsx)(a.mo,{children:"="}),(0,s.jsx)(a.mtext,{mathvariant:"bold",children:"origin"}),(0,s.jsx)(a.mo,{children:"+"}),(0,s.jsx)(a.mtext,{children:"fraction"}),(0,s.jsx)(a.mo,{children:"\xd7"}),(0,s.jsx)(a.mtext,{mathvariant:"bold",children:"direction"}),(0,s.jsx)(a.mo,{separator:"true",children:","}),(0,s.jsx)(a.mspace,{width:"1em"}),(0,s.jsx)(a.mtext,{children:"with\xa0fraction"}),(0,s.jsx)(a.mo,{children:"\u2208"}),(0,s.jsx)(a.mo,{stretchy:"false",children:"["}),(0,s.jsx)(a.mn,{children:"0"}),(0,s.jsx)(a.mo,{separator:"true",children:","}),(0,s.jsx)(a.mi,{mathvariant:"normal",children:"\u221e"}),(0,s.jsx)(a.mo,{stretchy:"false",children:")"}),(0,s.jsx)(a.mi,{mathvariant:"normal",children:"."})]}),(0,s.jsx)(a.annotation,{encoding:"application/x-tex",children:"\\textbf{hit} = \\textbf{origin} + \\textrm{fraction} \\times \\textbf{direction}, \\quad \\textrm{with fraction} \\in [0,\\infty)."})]})})}),(0,s.jsxs)(a.span,{className:"katex-html","aria-hidden":"true",children:[(0,s.jsxs)(a.span,{className:"base",children:[(0,s.jsx)(a.span,{className:"strut",style:{height:"0.6944em"}}),(0,s.jsx)(a.span,{className:"mord text",children:(0,s.jsx)(a.span,{className:"mord textbf",children:"hit"})}),(0,s.jsx)(a.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,s.jsx)(a.span,{className:"mrel",children:"="}),(0,s.jsx)(a.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,s.jsxs)(a.span,{className:"base",children:[(0,s.jsx)(a.span,{className:"strut",style:{height:"0.8889em",verticalAlign:"-0.1944em"}}),(0,s.jsx)(a.span,{className:"mord text",children:(0,s.jsx)(a.span,{className:"mord textbf",children:"origin"})}),(0,s.jsx)(a.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,s.jsx)(a.span,{className:"mbin",children:"+"}),(0,s.jsx)(a.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,s.jsxs)(a.span,{className:"base",children:[(0,s.jsx)(a.span,{className:"strut",style:{height:"0.7778em",verticalAlign:"-0.0833em"}}),(0,s.jsx)(a.span,{className:"mord text",children:(0,s.jsx)(a.span,{className:"mord textrm",children:"fraction"})}),(0,s.jsx)(a.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,s.jsx)(a.span,{className:"mbin",children:"\xd7"}),(0,s.jsx)(a.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,s.jsxs)(a.span,{className:"base",children:[(0,s.jsx)(a.span,{className:"strut",style:{height:"0.8889em",verticalAlign:"-0.1944em"}}),(0,s.jsx)(a.span,{className:"mord text",children:(0,s.jsx)(a.span,{className:"mord textbf",children:"direction"})}),(0,s.jsx)(a.span,{className:"mpunct",children:","}),(0,s.jsx)(a.span,{className:"mspace",style:{marginRight:"1em"}}),(0,s.jsx)(a.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,s.jsx)(a.span,{className:"mord text",children:(0,s.jsx)(a.span,{className:"mord textrm",children:"with\xa0fraction"})}),(0,s.jsx)(a.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,s.jsx)(a.span,{className:"mrel",children:"\u2208"}),(0,s.jsx)(a.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,s.jsxs)(a.span,{className:"base",children:[(0,s.jsx)(a.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.jsx)(a.span,{className:"mopen",children:"["}),(0,s.jsx)(a.span,{className:"mord",children:"0"}),(0,s.jsx)(a.span,{className:"mpunct",children:","}),(0,s.jsx)(a.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,s.jsx)(a.span,{className:"mord",children:"\u221e"}),(0,s.jsx)(a.span,{className:"mclose",children:")"}),(0,s.jsx)(a.span,{className:"mord",children:"."})]})]})]})}),"\n",(0,s.jsx)(a.p,{children:"The direction given to Jitter does not need to be normalized. The normal returned by Jitter is the normalized surface normal of the collision target at the hit point."}),"\n",(0,s.jsx)(a.h2,{id:"generic-ray-cast-for-isupportmap",children:"Generic Ray Cast for ISupportMap"}),"\n",(0,s.jsxs)(a.p,{children:["To cast a ray against any object implementing ",(0,s.jsx)(a.code,{children:"ISupportMap"}),", use ",(0,s.jsx)(a.code,{children:"NarrowPhase.RayCast"}),":"]}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-cs",children:"public static bool RayCast(ISupportMap support, \n                           ref JMatrix orientation, ref JVector position,\n                           ref JVector origin, ref JVector direction, \n                           out float fraction, out JVector normal)\n"})}),"\n",(0,s.jsx)(a.h2,{id:"ray-cast-against-shapes",children:"Ray Cast Against Shapes"}),"\n",(0,s.jsx)(a.p,{children:"The world class offers two ray cast methods:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-cs",children:"public bool RayCast(Shape shape, JVector origin, JVector direction,\n                    out JVector normal, out float fraction)\n"})}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-cs",children:"public bool RayCast(JVector origin, JVector direction, \n                    RayCastFilterPre? pre, RayCastFilterPost? post,\n                    out Shape? shape, out JVector normal, out float fraction)\n"})}),"\n",(0,s.jsx)(a.p,{children:"The first method can be used to cast a ray against a single shape. The second method tests a ray against the world. Use the ray cast filter to get information about possible candidates or to avoid collision with specific shapes entirely. For example, a bullet may always be able to penetrate a wall; the pre-filter can be used to discard any collision with the wall. For a wall with non-uniform thickness, the bullet may only be able to penetrate the thinner part. In this case, the post-filter can be used to get information on where the ray hit the wall and, based on that information, decide whether to drop the collision."})]})}function h(e={}){const{wrapper:a}={...(0,n.R)(),...e.components};return a?(0,s.jsx)(a,{...e,children:(0,s.jsx)(m,{...e})}):m(e)}},8453:(e,a,t)=>{t.d(a,{R:()=>r,x:()=>c});var s=t(6540);const n={},i=s.createContext(n);function r(e){const a=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function c(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),s.createElement(i.Provider,{value:a},e.children)}}}]);