"use strict";(self.webpackChunkjitterphysics=self.webpackChunkjitterphysics||[]).push([[742],{9402:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>d,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>c});var t=i(4848),o=i(8453);const s={},d="World Entities",r={id:"documentation/01world-entities",title:"World Entities",description:"For a more detailed description of the entities of a world, namely Islands, Shapes, RigidBodies, Constraints, and Arbiters, refer to the corresponding documentation pages.",source:"@site/docs/02_documentation/01world-entities.md",sourceDirName:"02_documentation",slug:"/documentation/01world-entities",permalink:"/docs/documentation/01world-entities",draft:!1,unlisted:!1,editUrl:"https://github.com/notgiven688/jitterphysics2/tree/main/docs/docs/02_documentation/01world-entities.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Unmanaged Memory",permalink:"/docs/documentation/00unmanaged-memory"},next:{title:"Simulation Step",permalink:"/docs/documentation/02simulation-step"}},a={},c=[{value:"Creating RigidBodies and Constraints",id:"creating-rigidbodies-and-constraints",level:3},{value:"Accessing Entities",id:"accessing-entities",level:3},{value:"Removing Entities",id:"removing-entities",level:3}];function l(e){const n={admonition:"admonition",code:"code",h1:"h1",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"world-entities",children:"World Entities"}),"\n",(0,t.jsx)(n.p,{children:"For a more detailed description of the entities of a world, namely Islands, Shapes, RigidBodies, Constraints, and Arbiters, refer to the corresponding documentation pages."}),"\n",(0,t.jsx)(n.h3,{id:"creating-rigidbodies-and-constraints",children:"Creating RigidBodies and Constraints"}),"\n",(0,t.jsxs)(n.p,{children:["Use ",(0,t.jsx)(n.code,{children:"world.CreateRigidBody()"})," to create a new instance of the RigidBody class. A typical code snippet for adding a unit cube to Jitter could look like this:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cs",children:"RigidBody body = world.CreateRigidBody();\nbody.Position = new JVector(0, 5, 0);\nvar shape = new BoxShape(1);\nbody.AddShape(shape);\n"})}),"\n",(0,t.jsx)(n.p,{children:"It is not valid to add the same instance of a shape to multiple bodies."}),"\n",(0,t.jsx)(n.admonition,{title:"Order of Initialization",type:"info",children:(0,t.jsxs)(n.p,{children:["When calling ",(0,t.jsx)(n.code,{children:"body.AddShape(shape)"}),", the shape is registered in the collision system of the engine and added to the spatial tree structure (AABB-tree) for efficient broad-phase collision detection. Make sure to not accidentally register many objects at (0, 0, 0). This may happen by repeatedly calling ",(0,t.jsx)(n.code,{children:"body.AddShape"}),", before specifying the positions of the associated rigid bodies."]})}),"\n",(0,t.jsxs)(n.p,{children:["Constraints are another type of entities that can be explicitly added to the world using ",(0,t.jsx)(n.code,{children:"world.CreateConstraint<T>(body1, body2)"}),", where T is a constraint. In the following example, two constraints (a HingeAngle and a BallSocket constraint) are added:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cs",children:"hingeAngle = world.CreateConstraint<HingeAngle>(body1, body2);\nhingeAngle.Initialize(hingeAxis, angle);\n\nballSocket = world.CreateConstraint<BallSocket>(body1, body2);\nballSocket.Initialize(hingeCenter);\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"CreateConstraint"})," always takes two bodies as parameters; the ",(0,t.jsx)(n.code,{children:"Initialize"})," method depends on the constraint used."]}),"\n",(0,t.jsx)(n.admonition,{title:"Constraint Initialization",type:"caution",children:(0,t.jsxs)(n.p,{children:["For all default constraints available in Jitter, ",(0,t.jsx)(n.code,{children:"constraint.Initialize"})," must be called once after ",(0,t.jsx)(n.code,{children:"world.CreateConstraint"}),"."]})}),"\n",(0,t.jsx)(n.h3,{id:"accessing-entities",children:"Accessing Entities"}),"\n",(0,t.jsxs)(n.p,{children:["Once created, ",(0,t.jsx)(n.strong,{children:"RigidBodies"})," are available as an ",(0,t.jsx)(n.code,{children:"ActiveList<RigidBody>"})," under ",(0,t.jsx)(n.code,{children:"world.RigidBodies"}),". You can loop over all rigid bodies in the world using a regular foreach loop or a simple for loop:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cs",children:"foreach(var body in world.RigidBodies)\n{\n    // ...\n}\n\nfor(int i = 0; i < world.RigidBodies.Count; i++)\n{\n    var body = world.RigidBodies[i];\n    // ...\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Note that the items in ",(0,t.jsx)(n.code,{children:"ReadOnlyActiveList<RigidBody>"})," are not necessarily in a fixed order; Jitter may rearrange items during a call to ",(0,t.jsx)(n.code,{children:"world.Step()"}),". However, active bodies (bodies which have not been inactivated by the engine) are guaranteed to be enumerated first. Using a for-loop, active and inactive bodies can be enumerated separately:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cs",children:"// enumerate all active bodies\nfor(int i = 0; i < world.RigidBodies.Active; i++)\n{\n    var body = world.RigidBodies[i];\n    // ...\n}\n\n// enumerate all inactive bodies\nfor(int i = world.RigidBodies.Active; i < world.RigidBodies.Count; i++)\n{\n    var body = world.RigidBodies[i];\n    // ...\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Constraints"})," are not directly available from the world class. Users can keep track of them independently or by enumerating the HashSet of constraints owned by the associated bodies, using ",(0,t.jsx)(n.code,{children:"body.Constraints"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Islands"})," and ",(0,t.jsx)(n.strong,{children:"Shapes"})," are also stored in ",(0,t.jsx)(n.code,{children:"ReadOnlyActiveList"}),"s and can be accessed using ",(0,t.jsx)(n.code,{children:"world.Islands"})," and ",(0,t.jsx)(n.code,{children:"world.Shapes"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"removing-entities",children:"Removing Entities"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"world.Remove"})," function has overloads for removing instances of ",(0,t.jsx)(n.code,{children:"RigidBody"}),", ",(0,t.jsx)(n.code,{children:"Arbiter"}),", and ",(0,t.jsx)(n.code,{children:"Constraint"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Removing a rigid body also removes all constraints and contacts in which the body is involved."}),"\n",(0,t.jsx)(n.admonition,{title:"Accessing Removed Entities",type:"caution",children:(0,t.jsxs)(n.p,{children:["Instances of ",(0,t.jsx)(n.code,{children:"RigidBody"}),", ",(0,t.jsx)(n.code,{children:"Arbiter"}),", and ",(0,t.jsx)(n.code,{children:"Constraint"})," store some of their data in unmanaged memory, which is automatically freed once the entities are removed from the world. Do not use these entities any longer, i.e., do not call functions or use their properties, otherwise, a NullReferenceException may be thrown."]})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>d,x:()=>r});var t=i(6540);const o={},s=t.createContext(o);function d(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:d(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);