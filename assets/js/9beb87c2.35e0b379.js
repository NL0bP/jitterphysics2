"use strict";(self.webpackChunkjitterphysics=self.webpackChunkjitterphysics||[]).push([[539],{5851:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>d,toc:()=>a});var t=n(4848),r=n(8453);const s={sidebar_position:5},l="Changelog",d={id:"changelog",title:"Changelog",description:"Jitter 2.4.6 (10-28-2024)",source:"@site/docs/changelog.md",sourceDirName:".",slug:"/changelog",permalink:"/docs/changelog",draft:!1,unlisted:!1,editUrl:"https://github.com/notgiven688/jitterphysics2/tree/main/docs/docs/changelog.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Collision Filters",permalink:"/docs/documentation/06filters"}},o={},a=[{value:"Jitter 2.4.6 (10-28-2024)",id:"jitter-246-10-28-2024",level:3},{value:"Jitter 2.4.5 (10-07-2024)",id:"jitter-245-10-07-2024",level:3},{value:"Jitter 2.4.4 (09-14-2024)",id:"jitter-244-09-14-2024",level:3},{value:"Jitter 2.4.3 (08-31-2024)",id:"jitter-243-08-31-2024",level:3},{value:"Jitter 2.4.2 (08-26-2024)",id:"jitter-242-08-26-2024",level:3},{value:"Jitter 2.4.1 (08-21-2024)",id:"jitter-241-08-21-2024",level:3},{value:"Jitter 2.4.0 (08-10-2024)",id:"jitter-240-08-10-2024",level:3},{value:"Jitter 2.3.1 (06-02-2024)",id:"jitter-231-06-02-2024",level:3},{value:"Jitter 2.3.0 (05-20-2024)",id:"jitter-230-05-20-2024",level:3},{value:"Jitter 2.2.1 (04-29-2024)",id:"jitter-221-04-29-2024",level:3},{value:"Jitter 2.2.0 (01-02-2024)",id:"jitter-220-01-02-2024",level:3},{value:"Jitter 2.1.1 (12-17-2023)",id:"jitter-211-12-17-2023",level:3},{value:"Jitter 2.1.0 (12-10-2023)",id:"jitter-210-12-10-2023",level:3},{value:"Jitter 2.0.1 (10-28-2023)",id:"jitter-201-10-28-2023",level:3},{value:"Jitter 2.0.0 (10-22-2023)",id:"jitter-200-10-22-2023",level:3}];function c(e){const i={code:"code",h1:"h1",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.header,{children:(0,t.jsx)(i.h1,{id:"changelog",children:"Changelog"})}),"\n",(0,t.jsx)(i.h3,{id:"jitter-246-10-28-2024",children:"Jitter 2.4.6 (10-28-2024)"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Breaking Change:"})," Jitter world is now constructed using World.Capacity."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Breaking Change:"})," World.RayCast moved to World.DynamicTree.RayCast."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Breaking Change:"})," Renamed NumberSubsteps to SubstepCount."]}),"\n",(0,t.jsxs)(i.li,{children:["Added split impulses. ",(0,t.jsx)(i.strong,{children:"Breaking Change:"})," SolverIterations property is now a tuple."]}),"\n",(0,t.jsx)(i.li,{children:"Several smaller improvements in the API."}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"jitter-245-10-07-2024",children:"Jitter 2.4.5 (10-07-2024)"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Added new methods to NarrowPhase: Distance and Overlap."}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Breaking Change:"}),"  Renamed NarrowPhase.SweepTest to NarrowPhase.Sweep."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Breaking Change:"}),"  Renamed NarrowPhase.GJKEPA to NarrowPhase.Collision."]}),"\n",(0,t.jsx)(i.li,{children:"Made PointTest, Raycast and SweepTest to use new SimplexSolver and SimplexSolverAB implementations."}),"\n",(0,t.jsx)(i.li,{children:"Fixed normal in GJKEPA for separating case."}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"jitter-244-09-14-2024",children:"Jitter 2.4.4 (09-14-2024)"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Implemented fixes and workarounds for using Jitter with a debugger attached."}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"jitter-243-08-31-2024",children:"Jitter 2.4.3 (08-31-2024)"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Correct corner case beeing wrong in MPR collision detection due to typo (bug fix)."}),"\n",(0,t.jsx)(i.li,{children:"FatTriangleShape level did not properly take transformations into account (bug fix)."}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"jitter-242-08-26-2024",children:"Jitter 2.4.2 (08-26-2024)"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Added FatTriangleShape to give triangles thickness which can be useful for static triangle meshes."}),"\n",(0,t.jsx)(i.li,{children:"Removal from potential pairs in DynamicTree ignores filters from now on (bug fix)."}),"\n",(0,t.jsx)(i.li,{children:"Use sweep tests for speculative contacts, vastly improving simulation quality in this scenario."}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Breaking Change:"})," Redefinition of NarrowPhase.SweepTest results."]}),"\n",(0,t.jsx)(i.li,{children:"Improved TriangleEdgeCollisionFilter."}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"jitter-241-08-21-2024",children:"Jitter 2.4.1 (08-21-2024)"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Improved TriangleEdgeCollisionFilter."}),"\n",(0,t.jsx)(i.li,{children:"Implemented analytical box and sphere ray casting."}),"\n",(0,t.jsx)(i.li,{children:"Made Restitution and Friction public in Contact."}),"\n",(0,t.jsx)(i.li,{children:"Improved DynamicTree interface."}),"\n",(0,t.jsx)(i.li,{children:"Add Debug.Asserts in ActiveList."}),"\n",(0,t.jsx)(i.li,{children:"Mark ArbiterKey as readonly."}),"\n",(0,t.jsx)(i.li,{children:"Added enumerator to PairHashSet."}),"\n",(0,t.jsx)(i.li,{children:"Changed ShapeHelper.MakeHull to take a generic of type ICollection."}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"jitter-240-08-10-2024",children:"Jitter 2.4.0 (08-10-2024)"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Improved TrimPotentialPairs logic."}),"\n",(0,t.jsx)(i.li,{children:"Optimized quaternion vector transformation."}),"\n",(0,t.jsx)(i.li,{children:"Extended functionality of ContactData.UsageMask."}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Breaking Change:"})," Overhauled the shape system. Regular shapes (box, sphere, capsule, ...) now derive from RigidBodyShape. Some method signatures changed slightly, e.g. ray casting."]}),"\n",(0,t.jsx)(i.li,{children:"Improved exceptions."}),"\n",(0,t.jsx)(i.li,{children:"Added ReferenceFrameAttribute."}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"jitter-231-06-02-2024",children:"Jitter 2.3.1 (06-02-2024)"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"ReadOnly wrappers (ReadOnlyList, ReadOnlyHashset) are now structs."}),"\n",(0,t.jsx)(i.li,{children:"Shapes with very small dimensions might have close to zero or zero mass/inertia. Creating rigid bodies from them now throws an exception (use body.AddShape(shape, setMassInertia: false) to not use the shape's mass properties)."}),"\n",(0,t.jsx)(i.li,{children:"Added BeginCollide and EndCollide events per body."}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"jitter-230-05-20-2024",children:"Jitter 2.3.0 (05-20-2024)"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Added RigidBody.RemoveShape overload to remove multiple shapes at once."}),"\n",(0,t.jsx)(i.li,{children:"Marked Rigid.ClearShapes deprecated."}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Breaking Change:"})," Use JQuaternion for orientations. Sorry for the API break."]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"jitter-221-04-29-2024",children:"Jitter 2.2.1 (04-29-2024)"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Add optional activate parameter to world.AddShape."}),"\n",(0,t.jsx)(i.li,{children:"Add NarrowPhase.SweepTest."}),"\n",(0,t.jsx)(i.li,{children:"EPA collision detection: various improvements."}),"\n",(0,t.jsx)(i.li,{children:"Improve exit condition for RayCast and PointTest."}),"\n",(0,t.jsx)(i.li,{children:"Remove redundant ArgumentException for zero mass shapes."}),"\n",(0,t.jsx)(i.li,{children:"Handle zero time steps. Throw ArgumentException for negative time steps."}),"\n",(0,t.jsx)(i.li,{children:"Add joint base class to joint classes."}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"jitter-220-01-02-2024",children:"Jitter 2.2.0 (01-02-2024)"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Breaking Change:"})," Renamed ",(0,t.jsx)(i.code,{children:"Raycast"})," to ",(0,t.jsx)(i.code,{children:"RayCast"}),"."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"world.Remove(world.NullBody)"})," does now remove all shapes, constraints and contacts associated with NullBody."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"world.AddShape(shape)"})," respects the activation state of the associated rigid body. Most notable: performance improvement when directly adding ",(0,t.jsx)(i.code,{children:"TriangleShape"}),"s to world.NullBody for static geometry."]}),"\n",(0,t.jsx)(i.li,{children:"Performance improvements for ConvexHullShape."}),"\n",(0,t.jsx)(i.li,{children:"Improved termination condition in GJKEPA collision detection."}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"jitter-211-12-17-2023",children:"Jitter 2.1.1 (12-17-2023)"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["Fixed O(n^2) problem in ",(0,t.jsx)(i.code,{children:"TriangleMesh"})," due to hash collisions."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"WorldBoundingBox"})," of ",(0,t.jsx)(i.code,{children:"Shape"})," is now updated even if no ",(0,t.jsx)(i.code,{children:"RigidBody"})," is attached."]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"jitter-210-12-10-2023",children:"Jitter 2.1.0 (12-10-2023)"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["Added debug drawing for rigid bodies (",(0,t.jsx)(i.code,{children:"RigidBody.DebugDraw"}),")."]}),"\n",(0,t.jsxs)(i.li,{children:["Fixed a bug in ",(0,t.jsx)(i.code,{children:"CalculateMassInertia"})," within ",(0,t.jsx)(i.code,{children:"TransformedShape.cs"}),"."]}),"\n",(0,t.jsxs)(i.li,{children:["Improved ray casting performance and introduced ",(0,t.jsx)(i.code,{children:"NarrowPhase.PointTest"}),"."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Breaking Change:"})," Inverted behavior of ",(0,t.jsx)(i.code,{children:"BroadPhaseCollisionFilter"}),"."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Breaking Change:"})," Inverted definition of damping factors in ",(0,t.jsx)(i.code,{children:"RigidBody.Damping"})," (0 = no damping, 1 = immediate halt)."]}),"\n",(0,t.jsxs)(i.li,{children:["Added ",(0,t.jsx)(i.code,{children:"RigidBody.SetMassInertia"})," overload to enable setting the inverse inertia to zero."]}),"\n",(0,t.jsx)(i.li,{children:"An exception is now thrown when a body's mass is set to zero."}),"\n",(0,t.jsxs)(i.li,{children:["Fixed a bug in the friction handling in ",(0,t.jsx)(i.code,{children:"Contact.cs"}),"."]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"jitter-201-10-28-2023",children:"Jitter 2.0.1 (10-28-2023)"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Fixed a bug in contact initialization which affected soft body physics."}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"jitter-200-10-22-2023",children:"Jitter 2.0.0 (10-22-2023)"}),"\n",(0,t.jsx)(i.p,{children:"Initial stable Release."})]})}function h(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>l,x:()=>d});var t=n(6540);const r={},s=t.createContext(r);function l(e){const i=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function d(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),t.createElement(s.Provider,{value:i},e.children)}}}]);