"use strict";(self.webpackChunkjitterphysics=self.webpackChunkjitterphysics||[]).push([[254],{9470:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>a,toc:()=>l});var s=o(4848),n=o(8453);const i={sidebar_position:4},r="Aftermath",a={id:"quickstart/teapots/aftermath",title:"Aftermath",description:"PointCloudShape vs ConvexHullShape",source:"@site/docs/01_quickstart/02_teapots/04-aftermath.md",sourceDirName:"01_quickstart/02_teapots",slug:"/quickstart/teapots/aftermath",permalink:"/docs/quickstart/teapots/aftermath",draft:!1,unlisted:!1,editUrl:"https://github.com/notgiven688/jitterphysics2/tree/main/docs/docs/01_quickstart/02_teapots/04-aftermath.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Hello World",permalink:"/docs/quickstart/teapots/pointcloudshape"},next:{title:"Overview",permalink:"/docs/category/overview"}},c={},l=[{value:"<code>PointCloudShape</code> vs <code>ConvexHullShape</code>",id:"pointcloudshape-vs-convexhullshape",level:3}];function h(e){const t={code:"code",h1:"h1",h3:"h3",header:"header",p:"p",...(0,n.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"aftermath",children:"Aftermath"})}),"\n",(0,s.jsxs)(t.h3,{id:"pointcloudshape-vs-convexhullshape",children:[(0,s.jsx)(t.code,{children:"PointCloudShape"})," vs ",(0,s.jsx)(t.code,{children:"ConvexHullShape"})]}),"\n",(0,s.jsxs)(t.p,{children:["In this example, we used the ",(0,s.jsx)(t.code,{children:"PointCloudShape"})," to simulate a rigid body with a convex hull. As the name suggests, this shape only requires a set of points \u2014 they don\u2019t need to lie exactly on a convex surface. By design, Jitter treats the convex hull of these points as the actual shape for collision detection."]}),"\n",(0,s.jsxs)(t.p,{children:["Although the algorithm used here is brute-force, it can be extremely fast: the data is stored in a linear memory layout, and SIMD instructions are used to accelerate the support function. Because of this, ",(0,s.jsx)(t.code,{children:"PointCloudShape"})," is usually the best choice for quickly and efficiently adding simple convex geometry to your simulation."]}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"ConvexHullShape"}),", on the other hand, is intended for more complex and detailed convex models. Unlike ",(0,s.jsx)(t.code,{children:"PointCloudShape"}),", this shape requires a precomputed convex hull provided as a list of triangles (",(0,s.jsx)(t.code,{children:"List<JTriangle>"}),"). Jitter does not generate this for you \u2014 you'll need to use third-party tools like Blender or dedicated convex hull libraries. The input mesh must be strictly convex for collision detection to work correctly."]}),"\n",(0,s.jsxs)(t.p,{children:["Internally, ",(0,s.jsx)(t.code,{children:"ConvexHullShape"})," uses a hill-climbing algorithm to compute the support function. While this approach is algorithmically more efficient than brute-force, the performance benefits only become noticeable with larger shapes. As a general rule of thumb, ",(0,s.jsx)(t.code,{children:"ConvexHullShape"})," starts to outperform ",(0,s.jsx)(t.code,{children:"PointCloudShape"})," at around 300 vertices or more."]})]})}function d(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,t,o)=>{o.d(t,{R:()=>r,x:()=>a});var s=o(6540);const n={},i=s.createContext(n);function r(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);