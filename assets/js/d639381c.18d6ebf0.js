"use strict";(self.webpackChunkjitterphysics=self.webpackChunkjitterphysics||[]).push([[772],{5335:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>r,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>c});var n=s(4848),i=s(8453);const a={},l="Simulation Step",o={id:"documentation/02simulation-step",title:"Simulation Step",description:"Call world.Step(float dt, bool multiThread = true) to simulate a time step of length dt. Every time world.Step is called, the following phases are performed in the engine:",source:"@site/docs/02_documentation/02simulation-step.md",sourceDirName:"02_documentation",slug:"/documentation/02simulation-step",permalink:"/docs/documentation/02simulation-step",draft:!1,unlisted:!1,editUrl:"https://github.com/notgiven688/jitterphysics2/tree/main/docs/docs/02_documentation/02simulation-step.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"World Entities",permalink:"/docs/documentation/01world-entities"},next:{title:"Ray Casting",permalink:"/docs/documentation/03raycasting"}},r={},c=[{value:"Step Size",id:"step-size",level:3},{value:"Multithreading",id:"multithreading",level:3},{value:"Substepping",id:"substepping",level:3}];function d(e){const t={admonition:"admonition",annotation:"annotation",code:"code",h1:"h1",h3:"h3",li:"li",math:"math",mi:"mi",mn:"mn",mrow:"mrow",ol:"ol",p:"p",pre:"pre",semantics:"semantics",span:"span",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"simulation-step",children:"Simulation Step"}),"\n",(0,n.jsxs)(t.p,{children:["Call ",(0,n.jsx)(t.code,{children:"world.Step(float dt, bool multiThread = true)"})," to simulate a time step of length dt. Every time ",(0,n.jsx)(t.code,{children:"world.Step"})," is called, the following phases are performed in the engine:"]}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsx)(t.li,{children:"All collisions are detected."}),"\n",(0,n.jsx)(t.li,{children:"Forces are integrated to update the velocities."}),"\n",(0,n.jsx)(t.li,{children:"Contacts and Constraints are solved in an iterative solver."}),"\n",(0,n.jsx)(t.li,{children:"Velocities are integrated to update the positions."}),"\n"]}),"\n",(0,n.jsx)(t.admonition,{title:"Units in Jitter",type:"info",children:(0,n.jsxs)(t.p,{children:["The unit system of Jitter is not explicitly defined. The engine utilizes 32-bit floating-point arithmetic and is optimized for objects with a size of 1 [len_unit]. For instance, the collision system uses length thresholds on the order of 1e-04 [len_unit]. It assumes a unit density of 1 [mass_unit/len_unit\xb3] for the mass properties of shapes. Consequently, the default mass of a unit cube is 1 [mass_unit]. The default value for gravity in Jitter is ",(0,n.jsxs)(t.span,{className:"katex",children:[(0,n.jsx)(t.span,{className:"katex-mathml",children:(0,n.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(t.semantics,{children:[(0,n.jsx)(t.mrow,{children:(0,n.jsx)(t.mn,{children:"9.81"})}),(0,n.jsx)(t.annotation,{encoding:"application/x-tex",children:"9.81"})]})})}),(0,n.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(t.span,{className:"base",children:[(0,n.jsx)(t.span,{className:"strut",style:{height:"0.6444em"}}),(0,n.jsx)(t.span,{className:"mord",children:"9.81"})]})})]})," [len_unit/time_unit\xb2], which aligns with the gravitational acceleration on Earth in metric units (m/s\xb2). Therefore, it is reasonable to use metric units (kg, m, s) when conceptualizing these values."]})}),"\n",(0,n.jsx)(t.h3,{id:"step-size",children:"Step Size"}),"\n",(0,n.jsxs)(t.p,{children:["To achieve accurate physical results, the time step (dt) should be as small as possible. However, to maintain interactive frame rates, it's not feasible to call ",(0,n.jsx)(t.code,{children:"world.Step"})," too frequently. A suitable compromise, aligning with the engine's design, is to choose dt=1/100. The time step should not exceed 1/60 to prevent potential simulation instability."]}),"\n",(0,n.jsx)(t.admonition,{title:"Time Step Size",type:"info",children:(0,n.jsx)(t.p,{children:"Maintain a consistent time step size, if possible, to avoid instabilities introduced by fluctuating time steps."})}),"\n",(0,n.jsxs)(t.p,{children:["Suppose your game using Jitter operates at a varying frame rate of 80-160 fps. In this case, calling ",(0,n.jsx)(t.code,{children:"world.Step(1.0f / 100.0f)"})," each frame might cause the simulated time to desynchronize from real time. You can implement a strategy to accumulate delta times (the discrepancy between the elapsed real time and the simulation step) and accordingly adjust the calls to ",(0,n.jsx)(t.code,{children:"world.Step(1.0f / 100.0f)"})," based on the magnitude of the delta time."]}),"\n",(0,n.jsx)(t.h3,{id:"multithreading",children:"Multithreading"}),"\n",(0,n.jsxs)(t.p,{children:["Jitter employs its own thread pool (",(0,n.jsx)(t.code,{children:"Parallelization.ThreadPool"}),") to distribute tasks across multiple threads, potentially processed by multiple cores. You can modify the number of worker threads managed by the thread pool using ",(0,n.jsx)(t.code,{children:"threadPool.ChangeThreadCount(int numThreads)"}),". A singleton pattern is used here, as demonstrated below:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-cs",children:"ThreadPool.Instance.ChangeThreadCount(4);\n"})}),"\n",(0,n.jsxs)(t.p,{children:["This adjusts the number of worker threads to four. Jitter utilizes the thread pool when the ",(0,n.jsx)(t.code,{children:"world.Step"})," method is invoked with the multiThread argument set to true. Aside from this, the engine manages multithreading internally. Except when injecting derived types of Jitter into the engine (like using custom constraints or registering Broad- and NarrowPhase interfaces), the program flow operates on a single main thread as usual."]}),"\n",(0,n.jsx)(t.admonition,{title:"Thread Safety",type:"info",children:(0,n.jsx)(t.p,{children:"Methods in Jitter are generally not thread-safe."})}),"\n",(0,n.jsx)(t.h3,{id:"substepping",children:"Substepping"}),"\n",(0,n.jsx)(t.p,{children:"Improving the simulation quality is feasible by employing smaller time steps. Substepping involves conducting collision detection once per step and executing several smaller time steps for the remainder of the simulation step, with reduced solver iterations in each step. The process is as follows:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsx)(t.li,{children:"All collisions are detected."}),"\n",(0,n.jsxs)(t.li,{children:["Repeat the next steps ",(0,n.jsxs)(t.span,{className:"katex",children:[(0,n.jsx)(t.span,{className:"katex-mathml",children:(0,n.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(t.semantics,{children:[(0,n.jsx)(t.mrow,{children:(0,n.jsx)(t.mi,{children:"n"})}),(0,n.jsx)(t.annotation,{encoding:"application/x-tex",children:"n"})]})})}),(0,n.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(t.span,{className:"base",children:[(0,n.jsx)(t.span,{className:"strut",style:{height:"0.4306em"}}),(0,n.jsx)(t.span,{className:"mord mathnormal",children:"n"})]})})]})," times with a step size of dt / ",(0,n.jsxs)(t.span,{className:"katex",children:[(0,n.jsx)(t.span,{className:"katex-mathml",children:(0,n.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(t.semantics,{children:[(0,n.jsx)(t.mrow,{children:(0,n.jsx)(t.mi,{children:"n"})}),(0,n.jsx)(t.annotation,{encoding:"application/x-tex",children:"n"})]})})}),(0,n.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(t.span,{className:"base",children:[(0,n.jsx)(t.span,{className:"strut",style:{height:"0.4306em"}}),(0,n.jsx)(t.span,{className:"mord mathnormal",children:"n"})]})})]}),", where ",(0,n.jsxs)(t.span,{className:"katex",children:[(0,n.jsx)(t.span,{className:"katex-mathml",children:(0,n.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(t.semantics,{children:[(0,n.jsx)(t.mrow,{children:(0,n.jsx)(t.mi,{children:"n"})}),(0,n.jsx)(t.annotation,{encoding:"application/x-tex",children:"n"})]})})}),(0,n.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(t.span,{className:"base",children:[(0,n.jsx)(t.span,{className:"strut",style:{height:"0.4306em"}}),(0,n.jsx)(t.span,{className:"mord mathnormal",children:"n"})]})})]})," is the number of substeps:","\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsx)(t.li,{children:"Forces are integrated to update the velocities."}),"\n",(0,n.jsx)(t.li,{children:"Contacts and Constraints are solved in an iterative solver."}),"\n",(0,n.jsx)(t.li,{children:"Velocities are integrated to update the positions."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"Utilizing smaller substeps enhances the simulation quality disproportionately. However, it also introduces a significant overhead due to the alternating between contact solving and force- and velocity-integration. Substepping is excellent for enhancing the overall quality of constraints, stabilizing large stacks of objects, and simulating large mass ratios (like heavy objects resting on light objects) with greater accuracy."}),"\n",(0,n.jsxs)(t.p,{children:["To adjust the number of substeps, use ",(0,n.jsx)(t.code,{children:"world.NumberSubsteps"}),". Setting it to one equates to conducting a regular step."]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>l,x:()=>o});var n=s(6540);const i={},a=n.createContext(i);function l(e){const t=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);